import geopandas as gpd
import networkx as nx
import matplotlib.pyplot as plt
from shapely.geometry import LineString, Point
import random
import heapq
import math
import matplotlib
matplotlib.use('TkAgg')
import time

# === Euclidean A* Helper Functions ===
def euclidean(p1, p2):
    return math.dist(p1, p2)

def a_star_euclidean(graph, start, goal):
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {node: float('inf') for node in graph.nodes}
    g_score[start] = 0
    f_score = {node: float('inf') for node in graph.nodes}
    f_score[start] = euclidean(start, goal)

    while open_set:
        _, current = heapq.heappop(open_set)

        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]

        for neighbor in graph.neighbors(current):
            tentative_g = g_score[current] + graph[current][neighbor]['weight']
            if tentative_g < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f_score[neighbor] = tentative_g + euclidean(neighbor, goal)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))
    return None

# === 1. Load Shapefile ===
shapefile_path = "/Users/vishnujordan/Downloads/Roads_Boundary/South_Clear_Creek_Roads.shp"
gdf = gpd.read_file(shapefile_path)

# === 2. Build Graph ===
G = nx.Graph()
for _, row in gdf.iterrows():
    geom = row.geometry
    if isinstance(geom, LineString):
        coords = list(geom.coords)
        for i in range(len(coords) - 1):
            p1, p2 = coords[i], coords[i + 1]
            distance = Point(p1).distance(Point(p2))
            G.add_edge(p1, p2, weight=distance)

# === 3. Pick Start and Goal ===
nodes = list(G.nodes)
start = random.choice(nodes)
goal = random.choice(nodes)
while goal == start or not nx.has_path(G, start, goal):
    goal = random.choice(nodes)

   

# # === 3. Fixed Start and Goal Coordinates ===
# fixed_start = (434189.6902, 4388844.3178)
# fixed_goal = (436216.7882, 4390206.0985)

# # === 4. Snap to Closest Graph Nodes ===
# def get_nearest_node(graph, point):
#     return min(graph.nodes, key=lambda n: Point(n).distance(Point(point)))

# start = get_nearest_node(G, fixed_start)
# goal = get_nearest_node(G, fixed_goal)

# print(f"✅ Snapped Start: {start}")
# print(f"✅ Snapped Goal: {goal}")

# # Check connectivity before running A*
# if not nx.has_path(G, start, goal):
#     print("❌ No path exists between start and goal (disconnected components)")
#     exit()












# === 4. Run Euclidean A* ===
path = a_star_euclidean(G, start, goal)
if path is None:
    print("No path found.")
    exit()
print(f"✅ Euclidean A* path has {len(path)} nodes")

# === 5. Prepare Visualization ===
x_vals = [pt[0] for pt in path]
y_vals = [pt[1] for pt in path]

# Compute G and H values along path
path_g_scores = []
path_h_scores = []
for i, node in enumerate(path):
    g = sum(G[path[j]][path[j+1]]['weight'] for j in range(i))
    h = euclidean(node, goal)
    path_g_scores.append(g)
    path_h_scores.append(h)

# === 6. Animate ===
plt.ion()
fig, ax = plt.subplots(figsize=(12, 12))
gdf.plot(ax=ax, color='lightgray', linewidth=0.5)

# Plot start, goal, and path
ax.plot(start[0], start[1], 'go', markersize=10, label='Start')
ax.plot(goal[0], goal[1], 'bo', markersize=10, label='Goal')
ax.plot(x_vals, y_vals, 'r--', linewidth=2, label='Euclidean A* Path')

# Create dot and text box
dot, = ax.plot([], [], 'ro', markersize=8)
text_box = ax.text(0.01, 0.99, '', transform=ax.transAxes, fontsize=12,
                   verticalalignment='top', bbox=dict(facecolor='white', alpha=0.7))

# Animate traversal with G, H, F display
for i, (x, y) in enumerate(zip(x_vals, y_vals)):
    dot.set_data([x], [y])
    g_val = path_g_scores[i]
    h_val = path_h_scores[i]
    f_val = g_val + h_val
    text_box.set_text(f"Step {i+1}/{len(path)}\nG: {g_val:.2f}\nH: {h_val:.2f}\nF: {f_val:.2f}")
    plt.draw()
    plt.pause(0.000000005)

plt.ioff()
plt.title("Euclidean A* Path Traversal with Heuristic/Cost Info")
plt.legend()
plt.axis('equal')
plt.show()
