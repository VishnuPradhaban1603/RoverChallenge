import geopandas as gpd
import networkx as nx
import matplotlib.pyplot as plt
from shapely.geometry import LineString, Point
import heapq
import math
import random
import matplotlib
matplotlib.use('TkAgg')

# === Euclidean Distance ===
def euclidean(p1, p2):
    return math.dist(p1, p2)

# === Bidirectional A* with fast animation ===
def bidirectional_a_star_sim(graph, start, goal, ax):
    if start == goal:
        return [start]

    fwd_open = [(0, start)]
    bwd_open = [(0, goal)]

    fwd_g = {n: float('inf') for n in graph.nodes}
    bwd_g = {n: float('inf') for n in graph.nodes}
    fwd_g[start] = 0
    bwd_g[goal] = 0

    fwd_parent = {}
    bwd_parent = {}

    visited = set()
    meeting_node = None
    best_path_len = float('inf')

    open_f_marker, = ax.plot([], [], 'ro', label='Forward Open', markersize=2)
    open_b_marker, = ax.plot([], [], 'bo', label='Backward Open', markersize=2)

    f_open_x, f_open_y = [], []
    b_open_x, b_open_y = [], []

    while fwd_open and bwd_open:
        _, fwd_node = heapq.heappop(fwd_open)
        _, bwd_node = heapq.heappop(bwd_open)

        visited.add(fwd_node)
        visited.add(bwd_node)

        f_open_x.append(fwd_node[0])
        f_open_y.append(fwd_node[1])
        b_open_x.append(bwd_node[0])
        b_open_y.append(bwd_node[1])
        open_f_marker.set_data(f_open_x, f_open_y)
        open_b_marker.set_data(b_open_x, b_open_y)
        plt.draw()
        plt.pause(0.00001)

        for neighbor in graph.neighbors(fwd_node):
            temp_g = fwd_g[fwd_node] + graph[fwd_node][neighbor]['weight']
            if temp_g < fwd_g[neighbor]:
                fwd_g[neighbor] = temp_g
                heapq.heappush(fwd_open, (temp_g + euclidean(neighbor, goal), neighbor))
                fwd_parent[neighbor] = fwd_node
                if neighbor in bwd_g:
                    total = temp_g + bwd_g[neighbor]
                    if total < best_path_len:
                        best_path_len = total
                        meeting_node = neighbor

        for neighbor in graph.neighbors(bwd_node):
            temp_g = bwd_g[bwd_node] + graph[bwd_node][neighbor]['weight']
            if temp_g < bwd_g[neighbor]:
                bwd_g[neighbor] = temp_g
                heapq.heappush(bwd_open, (temp_g + euclidean(neighbor, start), neighbor))
                bwd_parent[neighbor] = bwd_node
                if neighbor in fwd_g:
                    total = temp_g + fwd_g[neighbor]
                    if total < best_path_len:
                        best_path_len = total
                        meeting_node = neighbor

        if meeting_node:
            path = []
            node = meeting_node
            while node in fwd_parent:
                path.append(node)
                node = fwd_parent[node]
            path.append(start)
            path.reverse()
            node = meeting_node
            while node in bwd_parent:
                node = bwd_parent[node]
                path.append(node)
            return path

    return None

# === Load shapefile ===
shapefile = "/Users/vishnujordan/Downloads/Roads_Boundary/South_Clear_Creek_Roads.shp"
gdf = gpd.read_file(shapefile)

# === Build Graph ===
G = nx.Graph()
for _, row in gdf.iterrows():
    geom = row.geometry
    if isinstance(geom, LineString):
        coords = list(geom.coords)
        for i in range(len(coords) - 1):
            p1, p2 = coords[i], coords[i + 1]
            dist = Point(p1).distance(Point(p2))
            G.add_edge(p1, p2, weight=dist)

# === Choose Start & Goal with length between 250–500
nodes = list(G.nodes)
start, goal = None, None
for _ in range(1000):
    s, g = random.sample(nodes, 2)
    if nx.has_path(G, s, g):
        p = nx.shortest_path(G, s, g, weight='weight')
        if 250 <= len(p) <= 500:
            start, goal = s, g
            break

if not start:
    raise Exception("❌ Couldn't find suitable start and goal.")


# # === Fixed Start and Goal === for testing purpose
# fixed_start = (434189.6902, 4388844.3178)
# fixed_goal = (436216.7882, 4390206.0985)

# # Snap to nearest graph node
# # def get_nearest_node(graph, point):
# #     return min(graph.nodes, key=lambda n: Point(n).distance(Point(point)))

# start = get_nearest_node(G, fixed_start)
# goal = get_nearest_node(G, fixed_goal)

print(f"✅ Start snapped to: {start}")
print(f"✅ Goal snapped to: {goal}")

# Optional: check connectivity
if not nx.has_path(G, start, goal):
    raise Exception("❌ No path exists between start and goal.")



# === Visualization Setup ===
plt.ion()
fig, ax = plt.subplots(figsize=(12, 12))
gdf.plot(ax=ax, color='lightgray', linewidth=0.5)
ax.plot(start[0], start[1], 'go', markersize=10, label='Start')
ax.plot(goal[0], goal[1], 'bo', markersize=10, label='Goal')

# === Run Bidirectional A* with animation ===
path = bidirectional_a_star_sim(G, start, goal, ax)

if path:
    x_vals = [pt[0] for pt in path]
    y_vals = [pt[1] for pt in path]
    ax.plot(x_vals, y_vals, 'k-', linewidth=2, label='Final Path')
    ax.set_title("Bidirectional A* - Fast Simulation")
else:
    ax.set_title("No Path Found")

ax.legend()
ax.axis('equal')
plt.ioff()
plt.show()